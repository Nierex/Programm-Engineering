# Тема 10.  Декораторы и исключения
Отчет по Теме #10 выполнил:
- Донских Александр Сергеевич
- ИВТ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |




## Лабораторная работа №1
Напишите рекурсивную программу на Python, которая будет считать число Фибоначчи для 100. Используйте декоратор @lru_cache, чтобы программа не считала одни и те же значения при каждом вызове. Запустите её без декоратора и с ним — посмотрите разницу во времени.
Оформленный код
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_1.1.png)

- Вывод
Декоратор @lru_cache кэширует результаты функции, что позволяет избежать повторных вычислений в рекурсии. Без него программа работает очень долго (или не завершается), а с ним — мгновенно.
## Лабораторная работа №2
Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять, чтобы возраст был больше 0 и меньше 130. Обрабатывать только первые 2 аргумента.
Оформленный код
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]
        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)
    return output_func  

@check
def personal_info(name, age):
    print(f"Name: {name}  Age: {age}")

if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138)
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_1.2.png)

- Вывод
Декоратор позволяет добавить проверку входных данных без изменения логики основной функции. Если возраст некорректен — выводится сообщение "Недопустимый возраст".
## Лабораторная работа №3
Функция работает только с данными int, но недоверенный пользователь отправляет str. Используйте try/except/finally, чтобы программа не сломалась, а вывела ошибку или сообщение об успешном выполнении.
Оформленный код
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', '1', 'try', 'to', 'crash', 'your', 'site', 38, 45])
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_1.3.png)

- Вывод
Блок try/except защищает программу от падения при некорректных данных. finally гарантирует выполнение финального кода, даже если произошла ошибка.
## Лабораторная работа №4
Создайте собственное исключение, которое вызывается, если длина имени при регистрации больше 10 символов. В противном случае — выводится "Успешная регистрация".
Оформленный код
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_1.4.png)

- Вывод
Создание собственного исключения (NegativeValueException) позволяет гибко управлять ошибками в программе и делать их семантически понятными.
## Лабораторная работа №5
Создайте декоратор, который при создании класса выводит логи через __init__ и __call__. При запуске сайта должны выводиться сообщения: "Проверка перед запуском", "Усердная работа сайта", "Сайт выключен".
Оформленный код
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__  успешный запуск')
        self.func = func
    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')

@SiteChecker
def site():
    print(' Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_1.5.png)

- Вывод
Декоратор позволяет добавить логирование без изменения логики класса. __init__ и __call__ используются для перехвата создания и вызова объекта.

## Самостоятельная работа №1
Вовочка хочет знать, за какое время выполняется его программа. Напишите декоратор для функции fibonacci(), который будет выяснять, за какое время она выполняется. Используйте модуль time.
- Оформленный код
  import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Время выполнения: {end - start:.6f} секунд")
        return result
    return wrapper

@timer
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_2.1.png)
- Вывод
  Декоратор позволяет измерить время выполнения любой функции без изменения её кода. Это полезно для профилирования и оптимизации программ.
## Самостоятельная работа №2
Создайте пустой файл и файл с информацией. Напишите код программы: если файл пустой — выбросить исключение "файл пустой", если не пустой — вывести информацию из файла.
Оформленный код
import os

def read_file(filename):
    if not os.path.exists(filename):
        raise FileNotFoundError("Файл не найден")
    if os.path.getsize(filename) == 0:
        raise Exception("Файл пустой")
    with open(filename, 'r', encoding='utf-8') as f:
        content = f.read()
        print(content)

with open('empty.txt', 'w') as f:
    pass  

with open('data.txt', 'w', encoding='utf-8') as f:
    f.write("Привет, это данные!")

try:
    read_file('empty.txt')
except Exception as e:
    print(e)

try:
    read_file('data.txt')
except Exception as e:
    print(e)
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_2.2.png)
- Вывод
  Исключения позволяют корректно обрабатывать ошибки ввода/вывода. Проверка os.path.getsize() или file.read() помогает определить, пуст ли файл.
## Самостоятельная работа №3
Напишите функцию, которая складывает 2 и введённое пользователем число. Если пользователь введёт строку или другой неподходящий тип — вывести "Неподходящий тип данных. Ожидаемо число." Использовать try/except. Собственное исключение создавать нельзя.
- Оформленный код
  def add_two():
    try:
        user_input = input("Введите число: ")
        number = int(user_input)
        result = 2 + number
        print(f"Результат: {result}")
    except ValueError:
        print("Неподходящий тип данных. Ожидаемо число.")

add_two()
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_2.3.png)
- Вывод
  try/except защищает программу от падения при некорректных данных. Вместо аварийного завершения — выводится понятное сообщение.
## Самостоятельная работа №4
Создайте собственный декоратор, который будет использоваться для двух любых функций. Результатом выполнения задачи будет: класс декоратора, две связанные с ним функции, скриншот консоли с выполненной программой и подробные комментарии.
- Оформленный код
  class MyDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f">>> Вызов функции: {self.func.__name__}")
        result = self.func(*args, **kwargs)
        print(f">>> Функция {self.func.__name__} завершена")
        return result

@MyDecorator
def greet(name):
    print(f"Привет, {name}!")

@MyDecorator
def calculate(a, b):
    return a + b

greet("Александр")
print(calculate(5, 10))
![Тема_10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_2.4.png)

- Вывод
  Собственный декоратор — это класс, который реализует __init__ и __call__. Он позволяет добавлять логику до и после вызова функции, не меняя её код.
## Самостоятельная работа №5
Создайте собственное исключение, которое будет использоваться в двух любых функциях. Исключения, которые использовались ранее, нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код, где оно используется в двух местах, скриншот консоли с выполненной программой и подробные комментарии.
- Оформленный код
class InvalidInputError(Exception):

    pass

def divide_numbers(a, b):
    if b == 0:
        raise InvalidInputError("Деление на ноль запрещено")
    return a / b

def check_age(age):
    if age < 0:
        raise InvalidInputError("Возраст не может быть отрицательным")
    print(f"Возраст: {age}")

try:
    print(divide_numbers(10, 0))
except InvalidInputError as e:
    print(e)

try:
    check_age(-5)
except InvalidInputError as e:
    print(e)
![Тема 10](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab10_2.5.png)
- Вывод
Собственные исключения делают код более читаемым и семантически точным. Они позволяют явно указать, что именно пошло не так в программе.
Общий вывод: 
В 10 задачах освоены декораторы, исключения, работа с файлами и временем. Декораторы добавили логику без изменения кода, исключения обеспечили устойчивость, собственные исключения сделали код понятнее.
