# Тема 4. Функции и модули
Отчет по Теме #4 выполнил:
- Донских Александр Сергеевич
- ИВТ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + |  |
| Задание 7 | + |  |
| Задание 8 | + |  |
| Задание 9 | + |  |
| Задание 10 | + |  |



## Лабораторная работа №1
Напишите функцию, которая выполняет любое арифметическое действие и выводит результат напрямую в консоль. Запустите функцию через точку входа программы.
Оформленный код
def main():
    print(2 + 2)

if __name__ == '__main__':
    main()
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.1.png)

- Вывод
Функция может выполнять вычисления и сразу выводить результат без возврата значения. Точка входа (if __name__ == '__main__':) обеспечивает корректный запуск скрипта.


## Лабораторная работа №2
Напишите функцию, которая выполняет арифметическое действие и возвращает результат с помощью return. Выведите этот результат в консоль из основной части программы. Используйте точку входа.
Оформленный код
1) def main():
    return 2 + 2

if __name__ == '__main__':
    result = main()
    print(result)
2) def main():
    result = 2+2
    return result

if __name__ == '__main__':
    answer = main()
    print(answer)
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.2.1.png)
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.2.2.png)
- Вывод
Возврат значения через return делает функцию гибкой: результат можно использовать повторно, сохранять или обрабатывать дальше, а не только выводить.
## Лабораторная работа №3
Создайте функцию, принимающую два аргумента, выполняющую над ними арифметическое действие и возвращающую результат. Вызовите эту функцию внутри цикла несколько раз и выведите результаты.
Оформленный код
1)
def main(one, two):
    result = one + two
    return result

for i in range(5):
    x = 1
    y = 10
    answer = main(x, y) 
    print(answer)
2)def main(one, two):
    return one + two

for i in range(5):
    answer = main(one=1 , two = 10)
    print(answer)
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.3.1.png)
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.3.2.png)
- Вывод
Параметризация функции позволяет использовать её с разными данными. Циклы позволяют автоматизировать повторяющиеся вызовы, что повышает эффективность кода.
## Лабораторная работа №4
Реализуйте функцию, принимающую произвольное количество числовых аргументов с помощью *args, и выполняющую над ними арифметическое действие (например, расчёт среднего). Протестируйте её с разными наборами данных.
- Оформленный код
def main(*args):

    if len(args) == 0:
        return 0
    total = sum(args)
    average = total / len(args)
    return average

if __name__ == '__main__':
    result = main(10, 0, 1, 2, -1, 0, -1, 1, 2)
    print(f"Результат: {result}")
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.4.png)
- Вывод
Использование *args делает функцию универсальной — она может работать с любым количеством входных данных, что особенно полезно при неизвестном заранее объёме информации.
## Лабораторная работа №5
Напишите функцию, принимающую именованные аргументы через **kwargs, и выведите все переданные пары «ключ — значение» двумя способами: через .items() и через перебор ключей.
- Оформленный код
def main(**kwargs):
    """Функция, принимающая произвольные именованные аргументы через **kwargs"""

    # Вариант 1: перебираем пары ключ-значение через .items()
    print("=== Вариант 1: через .items() ===")
    for key, value in kwargs.items():
        print(f"{key}: {value}")

    print()

    # Вариант 2: перебираем только ключи, затем достаём значение по ключу
    print("=== Вариант 2: через ключи ===")
    for key in kwargs:
        print(f"{key} = {kwargs[key]}")

# Точка входа
if __name__ == '__main__':
    # Пример 1: передача аргументов напрямую
    print("Вызов 1: прямая передача аргументов")
    main(x=[1, 2, 3], y=[3, 3, 0])
    print("\n---\n")
    # Пример 2: передача словаря через распаковку **
    print("Вызов 2: распаковка словаря")
    data = {
        'z': [2, 3, 0],
        'q': [3, 3, 0],
        'w': [1, 1, 1]
    }
    main(**data)
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.5.png)
- Вывод
**kwargs позволяет передавать данные в виде словаря, что удобно для гибкой настройки поведения функции. Доступ к содержимому возможен разными способами, что даёт свободу в реализации.
## Лабораторная работа №6
Создайте две функции: первая принимает **kwargs с числовыми списками, вторая вычисляет среднее арифметическое. Первая функция должна вызывать вторую для каждого переданного списка и выводить результат.
- Оформленный код
def main(**kwargs):
    """Функция, работающая с **kwargs"""
    print("Расчёт среднего для переданных данных:")
    for key, values in kwargs.items():
        avg = mean(values)
        print(f"{key}. Mean = {avg}")

def mean(data):
    """Функция подсчёта среднего арифметического"""
    if len(data) == 0:
        return 0
    return sum(data) / float(len(data))

# Точка входа
if __name__ == '__main__':
    main(x=[1, 2, 3], y=[3, 3, 0], z=[5, 10, 15], w=[1, 1, 1])
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.6.png)
- Вывод
Разделение логики на отдельные функции повышает читаемость и повторное использование кода. Связка **kwargs + вспомогательная функция демонстрирует модульный подход к обработке данных.
## Лабораторная работа №7
Создайте отдельный файл с функцией. Импортируйте эту функцию в основной файл и вызовите её через точку входа.
- Оформленный код
from for_import import say_hello

if __name__ == '__main__':
    say_hello()

def say_hello():
    print("Hello students!")

![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.7.png)
- Вывод
Разделение кода на модули улучшает структуру проекта, упрощает поддержку и позволяет повторно использовать функции в других программах.
## Лабораторная работа №8
Напишите программу, которая запрашивает у пользователя число и выводит его корень, синус и косинус, используя модуль math. Реализуйте три способа импорта: весь модуль, конкретные функции, и from ... import *.
- Оформленный код
1)Импорт всего модуля math
  import math

def main():
    value = int(input('Введите значение: '))
    print(math.sqrt(value))
    print(math.sin(value))
    print(math.cos(value))

if __name__ == '__main__':
    main()
2)Импорт конкретных функций
from math import sqrt, sin, cos

def main():
    value = int(input('Введите значение: '))
    print(sqrt(value))
    print(sin(value))
    print(cos(value))

if __name__ == '__main__':
    main()
3)Импорт всех функций через *
from math import *

def main():
    value = int(input('Введите значение: '))
    print(sqrt(value))
    print(sin(value))
    print(cos(value))

if __name__ == '__main__':
    main()
    
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.8.1.png)

![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.8.2.png)

![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.8.3.png)
- Вывод
Python предоставляет гибкие способы импорта. Выбор метода влияет на читаемость и безопасность кода: явный импорт (from math import sqrt) предпочтительнее, чем import *.
## Лабораторная работа №9
Напишите программу, которая определяет, какой день недели будет через N дней, где N вводит пользователь. Используйте модуль datetime.
- Оформленный код
from datetime import datetime, timedelta

def main():
    today = datetime.today().date()
    day_name_today = today.strftime("%A")
    day_number_today = today.weekday() + 1
    print(f"Сегодня: {today} ({day_name_today}, день недели: {day_number_today})")
    try:
        n = int(input("Введите количество дней: "))
    except ValueError:
        print("Ошибка: введите целое число!")
        return
    future_date = today + timedelta(days=n)
    day_name_future = future_date.strftime("%A")
    day_number_future = future_date.weekday() + 1
    print(f"\nЧерез {n} дней будет: {future_date}")
    print(f"День недели: {day_name_future} (номер: {day_number_future})")

if __name__ == '__main__':
    main()
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.9.png)
- Вывод
Модуль datetime упрощает работу с датами и временем. С его помощью легко выполнять арифметические операции с датами и форматировать вывод.
## Лабораторная работа №10
Реализуйте программу с глобальной переменной, которая вычисляет площадь прямоугольника или треугольника по выбору пользователя. Ввод данных — через input(), расчёт — в отдельных функциях.
- Оформленный код
result = 0.0


def rectangle():
    """Вычисляет площадь прямоугольника"""
    a = float(input("Введите ширину: "))
    b = float(input("Введите высоту: "))
    global result
    result = a * b


def triangle():
    """Вычисляет площадь треугольника (по основанию и высоте)"""
    a = float(input("Введите основание: "))
    h = float(input("Введите высоту: "))
    global result
    result = 0.5 * a * h


# Точка входа
if __name__ == '__main__':
    figure = input("1 - прямоугольник, 2 - треугольник: ")
    if figure == '1':
        rectangle()
    elif figure == '2':
        triangle()
    else:
        print("Неверный выбор!")
        exit()
    print(f"Площадь: {result}")
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_1.10.png)

- Вывод
Глобальные переменные позволяют обмениваться данными между функциями, но их следует использовать осторожно, чтобы не нарушать инкапсуляцию и не усложнять отладку.
## Самостоятельная работа №1
Дайте подробный комментарий для каждой строки кода, написанного ниже. Комментарий нужен для каждой строки кода — опишите, что она делает. Особое внимание уделите оформлению документации функции (docstring).
- Оформленный код
from datetime import datetime  # Импортируем класс datetime из модуля datetime для работы с датой и временем
from math import sqrt          # Импортируем функцию sqrt (квадратный корень) из модуля math

def main(**kwargs):            # Определяем функцию main, принимающую произвольные именованные аргументы через **kwargs
    """                                # Начало документации функции (docstring)
    Функция принимает словарь с ключами, каждое значение которого — список из двух чисел.
    Для каждого ключа вычисляет выражение: sqrt(первое_число² + второе_число²) и выводит результат.
    """
    for key in kwargs.items():         # Перебираем пары (ключ, значение) в словаре kwargs
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  # Вычисляем гипотенузу по теореме Пифагора: sqrt(a² + b²)
        print(result)                  # Выводим результат в консоль

if __name__ == '__main__':             # Точка входа — выполняется только при прямом запуске файла
    start_time = datetime.now()        # Запоминаем текущее время перед началом выполнения программы
    main(                              # Вызываем функцию main с именованными аргументами
        one=[10, 3],                   # Ключ 'one', значение — список [10, 3]
        two=[5, 4],                    # Ключ 'two', значение — список [5, 4]
        three=[15, 13],                # Ключ 'three', значение — список [15, 13]
        four=[93, 53],                 # Ключ 'four', значение — список [93, 53]
        five=[133, 15]                 # Ключ 'five', значение — список [133, 15]
    )
    time_costs = datetime.now() - start_time  # Вычисляем разницу между текущим временем и временем начала
    print(f"Время выполнения программы - {time_costs}")  # Выводим затраченное время
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_2.1.png)
- Вывод
 Комментирование кода — важная часть разработки, особенно при работе в команде или при возврате к проекту спустя время. Документация функции (docstring) помогает другим разработчикам быстро понять её назначение, входные данные и поведение без изучения внутренней реализации. Использование стандартных модулей (datetime, math) и конструкций (**kwargs) требует чёткого пояснения, чтобы избежать недопонимания.
## Самостоятельная работа №2
Напишите программу, имитирующую бросок игральной кости с 6 гранями. Если выпадает 5 или 6 — вывести «Вы победили». Если 3 или 4 — выполнить рекурсивный вызов той же функции. Если 1 или 2 — вывести «Вы проиграли». Каждый результат броска должен выводиться в консоль. Используйте модуль random, одну функцию и точку входа.
- Оформленный код
import random

def roll_dice():
    """Бросает игральную кость (1–6) и выводит результат с реакциями"""
    dice_value = random.randint(1, 6)  # Генерируем случайное число от 1 до 6
    print(f"Выпало: {dice_value}")     # Выводим значение кубика
    if dice_value in [5, 6]:
        print("Вы победили!")
    elif dice_value in [3, 4]:
        print("Повторный бросок...")
        roll_dice()  # Рекурсивный вызов функции
    else:  # dice_value in [1, 2]
        print("Вы проиграли!")
# Точка входа
if __name__ == '__main__':
    roll_dice()
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_2.2.png)
- Вывод
Рекурсия — мощный инструмент для реализации повторяющихся действий без явных циклов. В данной задаче она моделирует правило «бросай снова», что соответствует игровой логике. Однако важно помнить, что чрезмерная глубина рекурсии может привести к ошибке переполнения стека. В реальных проектах рекурсию следует использовать с осторожностью и, при необходимости, заменять на итерации.
## Самостоятельная работа №3
Напишите программу, которая в течение 5 секунд каждую секунду выводит текущее время с точностью до секунды. Реализуйте программу с использованием цикла, модулей datetime и time, а также функции «усыпления» программы на 1 секунду.

- Оформленный код
 from datetime import datetime
import time

def main():
    """Выводит текущее время каждую секунду в течение 5 секунд"""
    for i in range(5):  # Цикл выполняется 5 раз
        current_time = datetime.now().strftime("%H:%M:%S")  # Получаем текущее время в формате ЧЧ:ММ:СС
        print(f"Текущее время: {current_time}")
        time.sleep(1)  # "Усыпляем" программу на 1 секунду

# Точка входа
if __name__ == '__main__':
    main()
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_2.3.png)

- Вывод
Модуль time.sleep() позволяет управлять временем выполнения программы, что полезно при создании таймеров, анимаций или имитации реального времени. Сочетание datetime (для получения точного времени) и time.sleep() (для задержки) демонстрирует, как синхронизировать логику программы с реальными временными интервалами.
## Самостоятельная работа №4
Напишите функцию, которая вычисляет среднее арифметическое от произвольного количества числовых аргументов. Количество аргументов заранее неизвестно. Программа должна содержать одну функцию и точку входа.
- Оформленный код
def calculate_average(*args):
    """Вычисляет среднее арифметическое от произвольного количества чисел"""
    if len(args) == 0:
        return 0.0
    total = sum(args)
    average = total / len(args)
    return average

if __name__ == '__main__':
    result = calculate_average(10, 20, 30, 40, 50)
    print(f"Среднее арифметическое: {result}")
    print(f"Среднее от трёх чисел: {calculate_average(5, 10, 15)}")
    print(f"Среднее от одного числа: {calculate_average(7)}")
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_2.4.png)

- Вывод
Использование *args делает функцию гибкой и универсальной — она может обрабатывать любое количество входных данных без изменения сигнатуры. Это особенно полезно при работе с динамическими наборами данных, например, при анализе результатов измерений или обработке пользовательского ввода. Такой подход повышает переиспользуемость кода.
## Самостоятельная работа №5
Создайте два Python-файла. В первом реализуйте функцию вычисления площади треугольника по формуле Герона. Во втором организуйте взаимодействие с пользователем: запрос сторон, вызов функции из первого файла и вывод результата. Программа должна корректно обрабатывать некорректные данные (например, невозможность построить треугольник).
- Оформленный код
 1) main.py
 from triangle import heron_area

def main():
    """Запрашивает у пользователя стороны треугольника и выводит его площадь"""
    try:
        a = float(input("Введите длину первой стороны: "))
        b = float(input("Введите длину второй стороны: "))
        c = float(input("Введите длину третьей стороны: "))
    except ValueError:
        print("Ошибка: введите числовые значения!")
        return
    area = heron_area(a, b, c)
    if area is None:
        print("Ошибка: эти стороны не могут образовать треугольник.")
    else:
        print(f"Площадь треугольника: {area:.2f}")
2) triangle.py

def heron_area(a, b, c):
    """
    Вычисляет площадь треугольника по формуле Герона.
    a, b, c — длины сторон треугольника.
    Возвращает площадь или None, если стороны не могут образовать треугольник.
    """
    if a + b <= c or a + c <= b or b + c <= a:
        return None
    p = (a + b + c) / 2.0
    area = (p * (p - a) * (p - b) * (p - c)) ** 0.5
    return area
# Точка входа
if __name__ == '__main__':
    main()
![Тема_4](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab4_2.5.png)
- Вывод
  Разделение программы на модули — фундаментальный принцип структурного программирования. Выделение вычислительной логики в отдельный файл (triangle.py) позволяет использовать её в других проектах, упрощает тестирование и повышает читаемость основного кода. Такой подход соответствует принципу единой ответственности и делает систему более поддерживаемой.

## Общие выводы по теме
В ходе выполнения лабораторных работ были освоены основные механизмы работы с функциями в Python: передача аргументов, использование *args и **kwargs, возврат значений, рекурсия и работа с глобальными переменными. Также отработаны навыки подключения и использования стандартных модулей (math, datetime, time, random), организация кода в несколько файлов, а также применение точек входа и обработка пользовательского ввода. Все задания способствовали формированию понимания структурированного, модульного подхода к разработке программ — что является важной основой для написания надёжного, читаемого и поддерживаемого кода.
