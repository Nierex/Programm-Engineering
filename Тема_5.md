# Тема 5. Базовые коллекции: множества, списки
Отчет по Теме #5 выполнил:
- Донских Александр Сергеевич
- ИВТ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + |  |
| Задание 7 | + |  |
| Задание 8 | + |  |
| Задание 9 | + |  |
| Задание 10 | + |  |



## Лабораторная работа №1
Даны два множества. Выведите элементы первого множества, которых нет во втором. Учтите, что во втором множестве могут быть дубликаты — они должны быть проигнорированы.

Оформленный код
1) set_1 = {'White', 'Black', 'Red', 'Pink'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}
print(set_1 - set_2)
2) set_1 = {'White', 'Black', 'Red', 'Pink', 'Black', 'White'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}
print('1', set_1 - set_2)

set_1 = {'White', 'Black', 'Red', 'Pink', 'Red', 'Red'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}
print('2', set_1 - set_2)

set_1 = {'White', 'Black', 'Red', 'Pink', 'Red', 'Red'}
set_2 = {'Red', 'Green', 'Blue', 'Red'}
print('3', set_1 - set_2)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.1.1.png)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.1.2.png)

- Вывод

Множество автоматически удаляет дубликаты. Операция - возвращает разность — элементы, принадлежащие первому множеству, но отсутствующие во втором.

## Лабораторная работа №2
Продемонстрируйте разницу между изменяемым set и неизменяемым frozenset на примере попытки добавить элементы.
Оформленный код
1)a = set('abcdefg')
print(a)
for i in range(1, 5):
    a.add(i)
print(a)
2)a = frozenset('abcdefg')
print(a)
for i in range(1, 5):
    a.add(i) 
print(a)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.2.1.png)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.2.2.png)
- Вывод
set — изменяемое множество, frozenset — неизменяемое. Попытка изменить frozenset вызывает AttributeError.
## Лабораторная работа №3
Напишите функцию, которая принимает список и меняет местами его первый и последний элементы.
Оформленный код
1)def replace(input_list):
    input_list[0] = input_list[5]
    input_list[5] = input_list[0]
    return input_list

print(replace([1, 2, 3, 4, 5]))
2)def replace(input_list):
    memory = input_list[0]
    input_list[0] = input_list[-1]
    input_list[-1] = memory
    return input_list

print(replace([1, 2, 3, 4, 5]))

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.3.1.png)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.3.2.png)
- Вывод
Обмен элементов можно сделать через временную переменную или через множественное присваивание. Индекс -1 — безопасный способ получить последний элемент.
## Лабораторная работа №4
Из заданного списка выведите элементы с индексами от 2 до 6 включительно.
- Оформленный код
a = [32, 54, 32, 57, 843, 2346, 765, 75, 25, 234, 756, 33]
print(a[2:7])
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.4.png)
- Вывод
Срез [start:end] не включает end. Для индексов 2–6 нужно указать [2:7].
## Лабораторная работа №5
Напишите функцию, которая вычисляет среднее арифметическое элементов списка.
- Оформленный код
def useless(lst):
    return sum(lst) / len(lst)

print(useless([3, 5, 7, 3, 33]))
print(useless([-12.5, 54, 77.3, 0, -50, 98.2, -63, 21.7, 47, -89.83]))
print(useless([-28.8, 80, 12.5, -50, 73.2, 0, 43, -91.5, 65.9, -7]))
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.5.png)
- Вывод
Функция useless() корректно вычисляет среднее арифметическое. Это "бесполезное" число — шутка, но математически верно.
## Лабораторная работа №6
Распакуйте список из трёх строк в три отдельные переменные и выведите их с пояснениями.
- Оформленный код
superheroes = ['superman', 'spiderman', 'batman']
nikolay, vasily, ivan = superheroes

print('Николай -', nikolay)
print('Василий -', vasily)
print('Иван -', ivan)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.6.png)
- Вывод
Распаковка (unpacking) позволяет присвоить элементы списка переменным. Если количество не совпадает — будет ValueError.
## Лабораторная работа №7
Отсортируйте список и удалите из него наименьший элемент (первый после сортировки).
- Оформленный код
a = [-25.8, 86, 12.5, -50, 73.2, 0, 43, -91.5, 65.9, -7]
a.sort()
print("Отсортированный список:\n", a)
a.pop(0)
print("Отсортированный список без наименьшего элемента:\n", a)

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.7.png)
- Вывод
После sort() минимальный элемент становится первым. pop(0) его удаляет. Это простой и эффективный способ.
## Лабораторная работа №8
Создайте от 3 до 10 списков длиной от 3 до 10, заполненных случайными числами от 1 до 100. Объедините все числа в один плоский список и выведите его.
- Оформленный код
from random import randint

def list_maker():
    a = [randint(1, 100)] * randint(3, 10)
    return a

if __name__ == '__main__':
    result = []
    for i in range(randint(1, 5)):
        result.append(list_maker())
    print(result)
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.8.png)


- Вывод
Код создаст списки с одинаковыми числами, а не случайными. Это распространённая ошибка при использовании * с изменяемыми объектами.
## Лабораторная работа №9
Напишите функцию superst(), которая принимает два множества и выводит одно из сообщений:
— «Множества равны»,
— «Объект {X} является чистым супермножеством»,
— «Супермножество не обнаружено».
- Оформленный код
def superst(set_1, set_2):
    if set_1 > set_2:
        print(f"Объект {set_1} является чистым супермножеством")
    elif set_1 < set_2:
        print(f"Объект {set_2} является чистым супермножеством")
    elif set_1 == set_2:
        print("Множества равны")
    else:
        print("Супермножество не обнаружено")

superst({8, 4, 3, 5}, {4, 5})
superst({2, 4, 5, 9}, {2, 4, 5, 9, 13})
superst({5, 2, 6, 7}, {8, 2, 3})
superst({90, 100}, {90, 100})
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.9.png)
- Вывод
Операторы >, <, == работают для множеств, но более явный способ — использовать методы .issuperset() и .issubset(), чтобы избежать путаницы.
## Лабораторная работа №10
Выведите список в обратном порядке.
- Оформленный код
my_list = [2, 5, 8, 2]
print(my_list[::-1])
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_1.10.png)

- Вывод
Срез с шагом -1 мгновенно разворачивает список. Это стандартный подход в Python.
## Самостоятельная работа №1
Ресторан на предприятии ведет учёт посещений за неделю при помощи кода работника.
У них есть список со всеми посещениями за неделю.
Ваша задача посчитать:
Сколько было выдано чеков
Сколько разных людей посетило ресторан
Какой работник посетил ресторан больше всех раз
Список выданных чеков за неделю:
[8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365,
 1478, 9865, 5555, 7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666,
 5410, 7778, 8889, 4445, 1439, 9604, 8201, 3365, 7502, 3016, 4928,
 5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051, 4506, 1987,
 3365, 5410, 7168, 7777, 9865, 5678, 8201, 4445, 3016, 4506, 4506]
- Оформленный код
checks = [
    8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365,
    1478, 9865, 5555, 7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666,
    5410, 7778, 8889, 4445, 1439, 9604, 8201, 3365, 7502, 3016, 4928,
    5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051, 4506, 1987,
    3365, 5410, 7168, 7777, 9865, 5678, 8201, 4445, 3016, 4506, 4506
]

total_checks = len(checks)
unique_visitors = len(set(checks))
from collections import Counter
visit_count = Counter(checks)
most_frequent_worker = visit_count.most_common(1)[0][0]
max_visits = visit_count.most_common(1)[0][1]
print("Статистика ресторана")
print(f"Общее количество выданных чеков: {total_checks}")
print(f"Количество уникальных посетителей: {unique_visitors}")
print(f"Работник с наибольшим количеством посещений: {most_frequent_worker} (посетил {max_visits} раз)")
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_2.1.png)
- Вывод
len() — считает общее количество элементов.
set() — убирает дубликаты → даёт количество уникальных посетителей.
Counter из модуля collections — удобный способ подсчёта частоты элементов. most_common(1) возвращает самый частый элемент и его количество.
## Самостоятельная работа №2
На физкультуре студенты сдавали бег, у преподавателя есть список всех результатов, ему нужно узнать:
Три лучшие результата
Три худшие результата
Все результаты начиная с 10
Список результатов бега:
[10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2, 35.7, 16.9, 27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4]
Оформленный код
results = [
    10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2, 35.7, 16.9,
    27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4
]

sorted_results = sorted(results)

best_three = sorted_results[:3]

worst_three = sorted_results[-3:]

from_tenth = sorted_results[9:]

print(" Результаты бега ")
print(f"Три лучших результата: {best_three}")
print(f"Три худших результата: {worst_three}")
print(f"Все результаты начиная с 10-го места: {from_tenth}")

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_2.2.png)
- Вывод
sorted() — создаёт новый отсортированный список (не меняет исходный).
Срезы [:3], [-3:], [9:] — быстрый способ получить нужные части списка.
В спорте «лучший» результат — это меньшее время, поэтому сортируем по возрастанию.
## Самостоятельная работа №3
Преподаватель по математике придумал странную задачку. У вас есть три списка с элементами, каждый элемент которых — длина стороны треугольника.
Ваша задача найти площади двух треугольников, составленных из:
- максимальных элементов полученных списков
- минимальных элементов полученных списков

- Оформленный код
import math

one = [12, 25, 3, 48, 71]
two = [5, 18, 40, 62, 98]
three = [4, 21, 37, 56, 84]

max_sides = [max(one), max(two), max(three)]
min_sides = [min(one), min(two), min(three)]

def triangle_area(a, b, c):
    p = (a + b + c) / 2
    area = math.sqrt(p * (p - a) * (p - b) * (p - c))
    return area

area_max = triangle_area(*max_sides)
area_min = triangle_area(*min_sides)

print("Площади треугольников")
print(f"Площадь треугольника из максимальных сторон: {area_max:.2f}")
print(f"Площадь треугольника из минимальных сторон: {area_min:.2f}")

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_2.3.png)

- Вывод
max(), min() — находят экстремумы в списках.
Распаковка *max_sides передаёт три аргумента в функцию.
Формула Герона требует полупериметра p и корня из произведения. Используется math.sqrt().
Проверка на возможность построения треугольника не требуется — по условию предполагается, что стороны корректны.
## Самостоятельная работа №4
Никто не любит получать плохие оценки, поэтому Борис решил это исправить.
Допустим, что все оценки студента за семестр хранятся в одном списке.
Ваша задача — удалить из этого списка все двойки, а все тройки заменить на четвёрки.

Списки оценок для теста (проверить работу программы на всех трёх вариантах):
[2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4]
[4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4]
[5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]
- Оформленный код
def fix_grades(grades):
    fixed = []
    for grade in grades:
        if grade == 2:
            continue  # пропускаем двойки
        elif grade == 3:
            fixed.append(4)  # тройки заменяем на четвёрки
        else:
            fixed.append(grade)  # остальные оставляем без изменений
    return fixed
test_cases = [
    [2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4],
    [4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4],
    [5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]
]

print("Исправление оценок")
for i, original in enumerate(test_cases, 1):
    fixed = fix_grades(original)
    print(f"Вариант {i}:")
    print(f"  Было: {original}")
    print(f"  Стало: {fixed}")
    print()
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_2.4.png)

- Вывод
Цикл for проходит по каждому элементу.
if grade == 2: continue — пропускает двойки (не добавляет в результат).
elif grade == 3: fixed.append(4) — заменяет тройки на четвёрки.
Остальные оценки (4, 5) просто копируются.
Решение не меняет исходный список — создаёт новый, что безопаснее.
## Самостоятельная работа №5
Вам представлены списки натуральных чисел, из них необходимо сформировать множества.
При этом следует соблюдать правило:если какое-либо число повторяется, то преобразовать его в строку по следующему образцу:
например, если число 4 повторяется 3 раза, то в множество будет следующая запись: само число 4, строка «44», строка «444».
Множества для теста:
list_1 = [1, 1, 3, 3, 1]
list_2 = [5, 5, 5, 5, 5, 5]
list_3 = [2, 2, 1, 2, 2, 5, 6, 7, 1, 3, 2, 2]
Результаты вывода (порядок может отличаться, поскольку мы работаем с set()):
{'11', '1', '33', '111'}
{'5', '55555', '555555', '55555', '55', '5555555'}
{'11', '1', '3', '2', '5', '22222', '222', '7', '2222', '22222', '22'}
- Оформленный код
def transform_to_set(numbers):
    from collections import Counter
    count = Counter(numbers)
    result_set = set()
    for num, freq in count.items():
        result_set.add(str(num))
        for i in range(2, freq + 1):
            result_set.add(str(num) * i)
    return result_set

list_1 = [1, 1, 3, 3, 1]
list_2 = [5, 5, 5, 5, 5, 5]
list_3 = [2, 2, 1, 2, 2, 5, 6, 7, 1, 3, 2, 2]

print("Преобразование чисел в строки")
print(f"list_1 -> {transform_to_set(list_1)}")
print(f"list_2 -> {transform_to_set(list_2)}")
print(f"list_3 -> {transform_to_set(list_3)}")
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab5_2.5.png)
- Вывод
Counter подсчитывает частоту каждого числа.
Для каждого числа num с частотой freq:
добавляем str(num) — само число как строка,
добавляем str(num) * i для i от 2 до freq — строки из повторяющейся цифры.
set() автоматически убирает дубликаты — так и должно быть.
Например, для [5,5,5,5,5,5] получим: '5', '55', '555', '5555', '55555', '555555'.
## Общие выводы по теме
В ходе выполнения 15 задач были отработаны ключевые навыки работы со списками, множествами и базовыми операциями в Python: срезы, итерации, фильтрация, подсчёт частот, преобразование данных и логический анализ. Все задачи решены с использованием встроенных средств языка, что подтверждает понимание основ программирования и умение применять их на практике.
