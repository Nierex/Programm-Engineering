# Тема 8.  Введение в ООП
Отчет по Теме #8 выполнил:
- Донских Александр Сергеевич
- ИВТ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |




## Лабораторная работа №1
Создайте класс Car с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задачи будет листинг кода с комментариями.
Оформленный код
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
my_car = Car("Toyota", "Corolla")
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_1.1.png)
- Вывод
Базовый класс с двумя атрибутами. Используется стандартный конструктор __init__. Объект создаётся корректно. 
## Лабораторная работа №2
Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину «поехать». Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задачи будет листинг кода с комментариями и получившийся вывод в консоли.
Оформленный код
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def drive(self):
        print(f"Driving the {self.make} {self.model}")
my_car = Car("Toyota", "Corolla")
my_car.drive()

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_1.2.png)
- Вывод
Метод drive() — простая демонстрация поведения объекта. Используется f-string для форматирования строки. Вывод в консоль подтверждает работоспособность.
## Лабораторная работа №3
Создайте новый класс ElectricCar с методом charge и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом зарядиться.
Оформленный код
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def drive(self):
        print(f"Driving the {self.make} {self.model}")
my_car = Car("Toyota", "Corolla")
my_car.drive()
class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity
    def charge(self):
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")
my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_1.3.png)
- Вывод
Наследование реализовано правильно. Используется super() для вызова родительского __init__. Дочерний класс расширяет функциональность родителя.
## Лабораторная работа №4
Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Выведите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу.
Оформленный код
class Car:
    def __init__(self, make, model):
        self._make = make       # Защищенный атрибут
        self.__model = model    # Приватный атрибут
    def drive(self):
        print(f"Driving the {self._make} {self.__model}")
my_car = Car("Toyota", "Corolla")
print(my_car._make)          # Доступ к защищенному атрибуту
# print(my_car.__model)      # Ошибка! Приватный атрибут не доступен
my_car.drive()
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_1.4.png)
- Вывод
Инкапсуляция реализована через соглашения: _ — защищённый, __ — приватный. Приватный атрибут недоступен вне класса — это соответствует принципам инкапсуляции.
## Лабораторная работа №5
Реализуйте полиморфизм создав основной (общий) класс Shape, а также еще два класса Rectangle и Circle. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади.
Оформленный код
class Shape:
    def area(self):
        pass
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius * self.radius
figures = [Rectangle(4, 5), Circle(3)]
for fig in figures:
    print(fig.area())
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_1.5.png)
- Вывод
Полиморфизм реализован: разные классы имеют одинаковый интерфейс (area()), но разную реализацию. Цикл обрабатывает объекты разных типов единообразно — это и есть полиморфизм.


## Самостоятельная работа №1
Самостоятельно создайте класс и его объект. Они должны отличаться от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задачи будет листинг кода и получившийся вывод консоли.
- Оформленный код
  class CoffeeMachine:
    def __init__(self, brand, capacity):
        self.brand = brand
        self.capacity = capacity

    def brew_coffee(self):
        return f"Молоть кофе на {self.brand} с ёмкостью {self.capacity} мл"

machine = CoffeeMachine("Bosch", 1500)
print(machine.brew_coffee())
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_2.1.png)
- Вывод
 Класс CoffeeMachine не используется в предыдущих задачах — значит, соответствует условию. Объект создаётся, метод вызывается — вывод в консоль есть. 
## Самостоятельная работа №2
Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях.
Оформленный код
class CoffeeMachine:
    def __init__(self, brand, capacity):
        self.brand = brand
        self.capacity = capacity
        self.water_level = 0  
    def brew_coffee(self):
        if self.water_level < 200:
            return "Недостаточно воды!"
        self.water_level -= 200
        return f"Кофе приготовлен на {self.brand}"
    def refill_water(self, amount):
        self.water_level += amount
        return f"Добавлено {amount} мл воды. Текущий уровень: {self.water_level} мл"
machine = CoffeeMachine("Bosch", 1500)
machine.refill_water(500)
print(machine.brew_coffee())
print(machine.brew_coffee())
print(machine.brew_coffee())
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_2.2.png)
- Вывод
  Добавлены новые атрибут (water_level) и методы (refill_water, улучшенный brew_coffee). Все отличаются от стандартных примеров — соответствуют условию.
## Самостоятельная работа №3
Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться от того, что указано в теоретическом материале (методичке) и лабораторных заданиях.
- Оформленный код
  class CoffeeMachine:
    def __init__(self, brand, capacity):
        self.brand = brand
        self.capacity = capacity
        self.water_level = 0
    def brew_coffee(self):
        if self.water_level < 200:
            return "Недостаточно воды!"
        self.water_level -= 200
        return f"Кофе приготовлен на {self.brand}"
    def refill_water(self, amount):
        self.water_level += amount
        return f"Добавлено {amount} мл воды. Текущий уровень: {self.water_level} мл"
machine = CoffeeMachine("Bosch", 1500)
machine.refill_water(500)

class SmartCoffeeMachine(CoffeeMachine):
    def __init__(self, brand, capacity, wifi_enabled=True):
        super().__init__(brand, capacity)
        self.wifi_enabled = wifi_enabled
    def brew_coffee_remotely(self):
        if not self.wifi_enabled:
            return "Wi-Fi выключен. Невозможно приготовить кофе удалённо."
        return f"Удалённое приготовление кофе на {self.brand} через Wi-Fi"
smart_machine = SmartCoffeeMachine("Nespresso", 1200, True)
print(smart_machine.brew_coffee_remotely())
print(smart_machine.brew_coffee())
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_2.3.png)
- Вывод
 Дочерний класс SmartCoffeeMachine наследуется от CoffeeMachine. Добавлены новые функции (Wi-Fi, удалённое управление) — это отличается от базовых примеров.
## Самостоятельная работа №4
Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться от того, что указано в теоретическом материале (методичке) и лабораторных заданиях.
- Оформленный код
  class CoffeeMachine:
    def __init__(self, brand, capacity):
        self.brand = brand
        self.capacity = capacity
        self.water_level = 0

    class CoffeeMachine:
        def __init__(self, brand, capacity):
            self._brand = brand 
            self.__capacity = capacity
        def get_capacity(self):
            return self.__capacity
        def set_capacity(self, new_capacity):
            if new_capacity > 0:
                self.__capacity = new_capacity
            else:
                print("Ёмкость должна быть положительной!")
        def brew_coffee(self):
            return f"Молоть кофе на {self._brand} с ёмкостью {self.__capacity} мл"
    machine = CoffeeMachine("Delonghi", 1000)
    print(machine.brew_coffee())
    print(machine.get_capacity())
    machine.set_capacity(1500)
    print(machine.get_capacity())

![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_2.4.png)
- Вывод
  Используются защищённый (_) и приватный (__) атрибуты. Доступ к приватному — только через геттер/сеттер. Это соответствует принципам инкапсуляции.
## Самостоятельная работа №5
Самостоятельно реализуйте полиморфизм. Он должен отличаться от того, что указан в теоретическом материале (методичке) и лабораторных заданиях.
- Оформленный код
class Beverage:
    def prepare(self):
        pass
class Tea(Beverage):
    def prepare(self):
        return "Завариваем чай..."
class Coffee(Beverage):
    def prepare(self):
        return "Готовим кофе..."
class Smoothie(Beverage):
    def prepare(self):
        return "Блендируем смузи..."
beverages = [Tea(), Coffee(), Smoothie()]
for drink in beverages:
    print(drink.prepare())
![Тема_5](https://github.com/Nierex/Programm-Engineering/blob/main/pic/Lab8_2.5.png)
- Вывод
Базовый класс Beverage с абстрактным методом prepare(). Каждый дочерний класс реализует его по-своему. Цикл обрабатывает разные типы единообразно — это полиморфизм.
Общий вывод
В ходе выполнения лабораторных и самостоятельных работ были успешно реализованы основные принципы объектно-ориентированного программирования: инкапсуляция, наследование, полиморфизм и абстракция — как на примере класса Car, так и на оригинальном примере с CoffeeMachine и напитками. Все задачи выполнены в соответствии с требованиями, код сопровождён комментариями, а выводы подтверждают корректность реализации.
